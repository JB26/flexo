#!/bin/bash

function fail_and_exit() {
  printf "%-50s %s\n" "$TESTCASE" "[FAILURE]"
  exit 1
}

function print_success() {
  printf "%-50s %s\n" "$TESTCASE" "[SUCCESS]"
}

function clear_pacman_cache() {
  mv /var/cache/pacman/pkg/* /tmp/verified || fail_and_exit
}

cd /tmp || exit 1

mkdir /tmp/verified || exit 1

# Wait for the flexo server to start and finish the mirror selection process.
sleep 5

## ==============================================================================================================
TESTCASE='flexo-test-install'
## Install a few packages via pacman. Using pacman (instead of just downloading the package via wget or curl)
## ensures that the file served by flexo is identical to the file from the remote mirror. This is due to the fact
## that pacman uses gpg signatures for verification.
## ==============================================================================================================

if /usr/bin/pacman -Sy --noconfirm --noprogressbar wget diffutils sed tcpdump parallel; then
  print_success
else
  fail_and_exit
fi

# Clear the pacman cache: We intend to simulate the situation where the package is cached by the flexo server,
# but not by the client that connects to the flexo server.
clean_pacman_cache

## ==============================================================================================================
TESTCASE='flexo-test-persistent-connections-c2s'
# Connections made from client-to-server (i.e., from pacman to flexo) should be persistent.
## ==============================================================================================================
/usr/bin/tcpdump -i lo 'tcp[tcpflags] & tcp-syn != 0' 2> /tmp/tcpdump-syn &
TCPDUMP_PID=$!
clear_pacman_cache

sleep .1

# There's no particular reason why we chose those packages, we just selected a few arbitrary packages that are small
# and have no dependencies.
/usr/bin/pacman -S --noconfirm --noprogressbar --downloadonly dosfstools hdparm gzip || fail_and_exit

kill $TCPDUMP_PID || fail_and_exit

if grep -q '2 packets captured' /tmp/tcpdump-syn; then
  # Expect only a single connection to be established, so we should have 2 SYN packets: One from pacman to flexo,
  # and a second one from flexo to pacman.
  print_success
else
  fail_and_exit
fi

## ==============================================================================================================
TESTCASE='flexo-test-persistent-connections-s2s'
# Connections made from server-to-server (i.e., from flexo to the remote mirror) should be persistent.
## ==============================================================================================================

/usr/bin/tcpdump -i eth0 'tcp[tcpflags] & tcp-syn != 0' 2> /tmp/tcpdump-syn &
TCPDUMP_PID=$!
clear_pacman_cache

# There's no particular reason why we chose those packages, we just selected a few arbitrary packages that are small
# and have no dependencies.
/usr/bin/pacman -S --noconfirm --noprogressbar --downloadonly libmnl npth bridge-utils which || fail_and_exit

kill $TCPDUMP_PID || fail_and_exit

if grep -q '0 packets captured' /tmp/tcpdump-syn; then
  # We assume that since we have already established a connection to the remote mirror, no new connection
  # will we established and therefore, no new SYN packets are sent or received.
  print_success
else
  fail_and_exit
fi

## ==============================================================================================================
TESTCASE='flexo-test-install-cached'
## Now that we have a package in flexo's cache, we install this package from the cache.
## ==============================================================================================================

# Reinstall wget, which has already been downloaded before and should therefore reside in cache.
if /usr/bin/pacman -Sy --noconfirm wget; then
  print_success
else
  fail_and_exit
fi

clear_pacman_cache

## ==============================================================================================================
TESTCASE='flexo-test-download-cached-concurrently'
## Download the cached package multiple times, concurrently.
## ==============================================================================================================

DOWNLOAD_PATH=$(pacman -Sp wget | grep wget)
if [[ -n $DOWNLOAD_PATH ]]; then
  seq 0 9 | parallel /usr/bin/wget -q "$DOWNLOAD_PATH" -O wget-{}
  VERIFIED_FILE=$(/usr/bin/find /tmp/verified -type f -name '*wget*')
  echo "$VERIFIED_FILE"
  for i in {0..9}; do
    # Files in /var/cache/pacman/pkg have been installed by pacman, and pacman verifies the content all
    # downloaded files. We can therefore assume that if a file downloaded by wget matches the file in
    # /var/cache/pacman/pkg, it has correctly been downloaded.
    if ! /usr/bin/cmp -s "wget-$i" "$VERIFIED_FILE"; then
      echo "Files do not match: wget-$i and $VERIFIED_FILE"
      fail_and_exit
    fi
  done
else
  fail_and_exit
fi
print_success

## ==============================================================================================================
TESTCASE='flexo-test-download-concurrently'
## Download the same uncached packages multiple times, concurrently.
## ==============================================================================================================

DOWNLOAD_PATH=$(/usr/bin/pacman -Sp curl | grep curl)
if [[ -n $DOWNLOAD_PATH ]]; then
  seq 0 9 | parallel /usr/bin/wget -q "$DOWNLOAD_PATH" -O curl-{}
  # We now install curl because installing packages with pacman also verifies the payload.
  # This allows us to then check if the previous 10 downloads match the verified payload.
  /usr/bin/pacman -S --noconfirm --noprogressbar curl || fail_and_exit
  VERIFIED_FILE=$(/usr/bin/find /var/cache/pacman/pkg -type f -name '*curl*')
  for i in {0..9}; do
    if ! /usr/bin/cmp -s "curl-$i" "$VERIFIED_FILE"; then
      echo "Files do not match: curl-$i and $VERIFIED_FILE"
      fail_and_exit
    fi
  done
  print_success
else
  fail_and_exit
fi

## ==============================================================================================================
TESTCASE='flexo-test-range-cached'
## Use HTTP range requests to skip the first few bytes of a file. The file is already cached by flexo.
## ==============================================================================================================

# No particular reason why we chose diffutils – just an arbitrary package that has already been downloaded.
DOWNLOAD_PATH=$(/usr/bin/pacman -Sp diffutils | grep diffutils)
if [[ -n $DOWNLOAD_PATH ]]; then
  echo "Downloading $DOWNLOAD_PATH"
  curl "$DOWNLOAD_PATH" -H "Range: bytes=1024-" >/tmp/diffutils-partial-downloaded || fail_and_exit
  if ! /usr/bin/cmp -s --ignore-initial=1024:0 /tmp/verified/diffutils* /tmp/diffutils-partial-downloaded; then
    echo "Files do not match: /tmp/diffutils-partial and /tmp/diffutils-partial-downloaded"
    fail_and_exit
  else
    print_success
  fi
else
  fail_and_exit
fi

## ==============================================================================================================
TESTCASE='flexo-test-range-non-cached'
## Use HTTP range requests to skip the first few bytes of a file. The file is not cached by flexo.
## ==============================================================================================================

# No particular reason why we chose the 'file' package – just an arbitrary package that has not been downloaded yet.
DOWNLOAD_URL=$(/usr/bin/pacman -Sp file | grep file)
if [[ -n $DOWNLOAD_URL ]]; then
  echo "Downloading $DOWNLOAD_URL"
  curl "$DOWNLOAD_URL" -L -H "Range: bytes=1024-" >/tmp/file-partial-downloaded || fail_and_exit
  /usr/bin/pacman -S --noconfirm --noprogressbar --downloadonly --nodeps file || fail_and_exit
  VERIFIED_FILE=$(/usr/bin/find /var/cache/pacman/pkg -type f -name 'file-*.zst')
  if [[ -n $VERIFIED_FILE ]]; then
    if ! /usr/bin/cmp -s --ignore-initial=1024:0 "$VERIFIED_FILE" /tmp/file-partial-downloaded; then
      echo "Files do not match: $VERIFIED_FILE and /tmp/file-partial-downloaded"
      fail_and_exit
    else
      print_success
    fi
  else
    fail_and_exit
  fi
else
  fail_and_exit
fi

## ==============================================================================================================
TESTCASE='flexo-test-resume-after-abort'
## Start a download, then abort it, then restart the download.
## ==============================================================================================================
/usr/bin/pacman -S --noconfirm --noprogressbar --downloadonly --nodeps archlinux-wallpaper &
PACMAN_PID=$!
sleep 0.75
kill "$PACMAN_PID"
sleep 0.75 # Wait a bit for flexo to detect that the socket has been closed.
rm /var/lib/pacman/db.lck
if /usr/bin/pacman -S --noconfirm --noprogressbar --downloadonly --nodeps archlinux-wallpaper; then
  print_success
else
  fail_and_exit
fi

## ==============================================================================================================
TESTCASE='flexo-test-concurrent-download-non-blocking'
# Downloading a larger file does not stop another client from obtaining a small file quickly.
## ==============================================================================================================
# First, we start downloading a relatively large file:
DOWNLOAD_PATH=$(pacman -Sp cppcheck | grep cppcheck)
/usr/bin/wget -q "$DOWNLOAD_PATH" -O /tmp/cppcheck &
WGET_PID=$!
# Next, we download a smaller package:
DOWNLOAD_PATH=$(pacman -Sp abook | grep abook)
/usr/bin/wget -q "$DOWNLOAD_PATH" -O /tmp/abook || fail_and_exit
# The download of the second package should have completed before the first download.
if ps -p $WGET_PID > /dev/null
then
  print_success
else
  fail_and_exit
fi

