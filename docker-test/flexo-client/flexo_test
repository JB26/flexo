#!/bin/bash

function fail_and_exit() {
  printf "%-40s %s\n" "$TESTCASE" "[FAILURE]"
  exit 1
}

function print_success() {
  printf "%-40s %s\n" "$TESTCASE" "[SUCCESS]"
}

function clear_pacman_cache() {
  mv /var/cache/pacman/pkg/* /tmp/verified || fail_and_exit
}

cd /tmp || exit 1

mkdir /tmp/verified || exit 1

# Wait for the flexo server to start and finish the mirror selection process.
sleep 5

## ==============================================================================================================
TESTCASE='flexo-test-install'
## Install two packages via pacman. Using pacman (instead of just downloading the package via wget or curl)
## ensures that the file served by flexo is identical to the file from the remote mirror. This is due to the fact
## that pacman uses gpg signatures for verification.
## ==============================================================================================================

if /usr/bin/pacman -Sy --noconfirm --noprogressbar wget diffutils sed; then
  print_success
else
  fail_and_exit
fi

# Clear the pacman cache: We intend to simulate the situation where the package is cached by the flexo server,
# but not by the client that connects to the flexo server.
clean_pacman_cache

## ==============================================================================================================
TESTCASE='flexo-test-install-cached'
## Now that we have a package in flexo's cache, we install this package from the cache.
## ==============================================================================================================

# Reinstall wget, which has already been downloaded before and should therefore reside in cache.
if /usr/bin/pacman -Sy --noconfirm wget; then
  print_success
else
  fail_and_exit
fi

clear_pacman_cache

## ==============================================================================================================
TESTCASE='flexo-test-download-cached-concurrently'
## Download the cached package multiple times, concurrently.
## ==============================================================================================================

DOWNLOAD_PATH=$(pacman -Sp wget)
if [[ -n $DOWNLOAD_PATH ]]; then
  for i in {0..9}; do
    echo "Downloading $DOWNLOAD_PATH"
    /usr/bin/wget -q "$DOWNLOAD_PATH" -O "wget-$i" &
  done
  sleep 5
  VERIFIED_FILE=$(/usr/bin/find /tmp/verified -type f -name '*wget*')
  echo "$VERIFIED_FILE"
  for i in {0..9}; do
    # Files in /var/cache/pacman/pkg have been installed by pacman, and pacman verifies the content all
    # downloaded files. We can therefore assume that if a file downloaded by wget matches the file in
    # /var/cache/pacman/pkg, it has correctly been downloaded.
    if ! /usr/bin/cmp -s "wget-$i" "$VERIFIED_FILE"; then
      echo "Files do not match: wget-$i and $VERIFIED_FILE"
      fail_and_exit
    fi
  done
else
  fail_and_exit
fi
print_success

## ==============================================================================================================
TESTCASE='flexo-test-download-concurrently'
## Download the same uncached packages multiple times, concurrently.
## ==============================================================================================================

DOWNLOAD_PATH=$(/usr/bin/pacman -Sp curl)
if [[ -n $DOWNLOAD_PATH ]]; then
  for i in {0..9}; do
    echo "Downloading $DOWNLOAD_PATH"
    /usr/bin/wget -q "$DOWNLOAD_PATH" -O "curl-$i" &
  done
  # Wait for all downloads to finish.
  sleep 5
  # We now install curl because installing packages with pacman also verifies the payload.
  # This allows us to then check if the previous 10 downloads match the verified payload.
  /usr/bin/pacman -S --noconfirm --noprogressbar curl || fail_and_exit
  VERIFIED_FILE=$(/usr/bin/find /var/cache/pacman/pkg -type f -name '*curl*')
  for i in {0..9}; do
    if ! /usr/bin/cmp -s "curl-$i" "$VERIFIED_FILE"; then
      echo "Files do not match: curl-$i and $VERIFIED_FILE"
      fail_and_exit
    fi
  done
  print_success
else
  /usr/bin/pacman -Sp curl
  fail_and_exit
fi

## ==============================================================================================================
TESTCASE='flexo-test-range-cached'
## Use HTTP range requests to skip the first few bytes of a file. The file is already cached by flexo.
## ==============================================================================================================

# No particular reason why we chose diffutils – just an arbitrary package that has already been downloaded.
DOWNLOAD_PATH=$(/usr/bin/pacman -Sp diffutils)
if [[ -n $DOWNLOAD_PATH ]]; then
  echo "Downloading $DOWNLOAD_PATH"
  curl "$DOWNLOAD_PATH" -H "Range: bytes=1024-" >/tmp/diffutils-partial-downloaded || fail_and_exit
  if ! /usr/bin/cmp -s --ignore-initial=1024:0 /tmp/verified/diffutils* /tmp/diffutils-partial-downloaded; then
    echo "Files do not match: /tmp/diffutils-partial and /tmp/diffutils-partial-downloaded"
    fail_and_exit
  else
    print_success
  fi
else
  fail_and_exit
fi

## ==============================================================================================================
TESTCASE='flexo-test-range-non-cached'
## Use HTTP range requests to skip the first few bytes of a file. The file is not cached by flexo.
## ==============================================================================================================

# No particular reason why we chose the 'file' package – just an arbitrary package that has not been downloaded yet.
DOWNLOAD_URL=$(/usr/bin/pacman -Sp file)
if [[ -n $DOWNLOAD_URL ]]; then
  echo "Downloading $DOWNLOAD_URL"
  curl "$DOWNLOAD_URL" -L -H "Range: bytes=1024-" >/tmp/file-partial-downloaded || fail_and_exit
  /usr/bin/pacman -S --noconfirm --noprogressbar file || fail_and_exit
  VERIFIED_FILE=$(/usr/bin/find /var/cache/pacman/pkg -type f -name 'file-*.zst')
  if [[ -n $VERIFIED_FILE ]]; then
    if ! /usr/bin/cmp -s --ignore-initial=1024:0 "$VERIFIED_FILE" /tmp/file-partial-downloaded; then
      echo "Files do not match: $VERIFIED_FILE and /tmp/file-partial-downloaded"
      fail_and_exit
    else
      print_success
    fi
  else
    fail_and_exit
  fi
else
  fail_and_exit
fi
